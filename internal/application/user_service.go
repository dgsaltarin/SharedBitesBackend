package application

import (
	"context"
	"errors"
	"fmt"
	"github.com/dgsaltarin/SharedBitesBackend/internal/domain"
	"github.com/dgsaltarin/SharedBitesBackend/internal/ports"
	"log"          // Use your logger
	"unicode/utf8" // For password length check
)

const minPasswordLength = 8 // Example minimum password length

// UserService defines the interface for user-related operations.
type UserService interface {
	CreateUser(ctx context.Context, name, email, password string) (*domain.User, error)
	// GetUser(ctx context.Context, userID uuid.UUID) (*domain.User, error) // Example read operation
}

// userService implements the UserService interface.
type userService struct {
	userRepo     ports.UserRepository
	firebaseAuth ports.FirebaseAuthProvider
}

// NewUserService creates a new user service instance.
func NewUserService(ur ports.UserRepository, fa ports.FirebaseAuthProvider) UserService {
	return &userService{
		userRepo:     ur,
		firebaseAuth: fa,
	}
}

// CreateUser orchestrates creating a user in Firebase and the local database.
func (s *userService) CreateUser(ctx context.Context, name, email, password string) (*domain.User, error) {
	// 1. Input Validation
	if name == "" {
		return nil, domain.ErrUserNameEmpty
	}
	if email == "" { // Add regex validation here if needed
		return nil, domain.ErrUserEmailEmpty
	}
	if utf8.RuneCountInString(password) < minPasswordLength {
		return nil, domain.ErrUserPasswordTooShort
	}

	// 2. Check if user exists in local DB (cheaper check first)
	_, err := s.userRepo.FindByEmail(ctx, email)
	if err == nil {
		// User found in DB
		return nil, domain.ErrUserAlreadyExists
	}
	if !errors.Is(err, domain.ErrUserNotFound) {
		// Unexpected DB error during lookup
		return nil, fmt.Errorf("failed checking existing user: %w", err)
	}
	// User not found in DB, proceed.

	// --- Start "transaction-like" block (with compensation) ---
	var createdFirebaseUID string = "" // Variable to hold UID for potential cleanup

	defer func() {
		// Compensation: If Firebase user was created but DB save failed, delete from Firebase.
		if err != nil && createdFirebaseUID != "" { // Check if an error occurred AND Firebase user was created
			log.Printf("COMPENSATION: Attempting to delete Firebase user %s due to failed DB creation for email %s", createdFirebaseUID, email)
			delErr := s.firebaseAuth.DeleteUser(context.Background(), createdFirebaseUID) // Use background context for cleanup
			if delErr != nil {
				// Log compensation failure, but don't overwrite original error 'err'
				log.Printf("ERROR: Failed to execute compensation (delete Firebase user %s): %v", createdFirebaseUID, delErr)
			} else {
				log.Printf("COMPENSATION: Successfully deleted Firebase user %s", createdFirebaseUID)
			}
		}
	}()

	// 3. Create user in Firebase
	createdFirebaseUID, err = s.firebaseAuth.CreateUser(ctx, email, password, name)
	if err != nil {
		// Error could be domain.ErrUserAlreadyExists (mapped by adapter) or domain.ErrFirebaseUserCreationFailed
		log.Printf("Failed to create user in Firebase for email %s: %v", email, err)
		return nil, err // Return the error from Firebase adapter (already mapped/wrapped)
	}
	// If we reach here, Firebase user was created successfully. 'createdFirebaseUID' is set.

	// 4. Create domain User object (DB ID will be generated by GORM on Save)
	domainUser, err := domain.NewUser(name, email)
	if err != nil {
		// Should not happen with prior validation, but handle defensively
		log.Printf("Error creating domain user object for email %s: %v", email, err)
		return nil, err // Return internal error, compensation logic will trigger
	}

	// 5. Save user to local database
	err = s.userRepo.Save(ctx, domainUser)
	if err != nil {
		// DB save failed. Log, compensation logic in defer will trigger.
		log.Printf("Failed to save user to database for email %s (Firebase UID: %s): %v", email, createdFirebaseUID, err)
		// err is already set, defer will handle cleanup
		// Map to a specific DB error if needed, but ErrDatabaseUserCreationFailed is likely sufficient.
		return nil, fmt.Errorf("failed to save user record: %w", domain.ErrDatabaseUserCreationFailed)
	}
	// --- End "transaction-like" block ---

	// If we reach here, both Firebase and DB creation succeeded.
	log.Printf("Successfully created user: DB_ID=%s, FirebaseUID=%s, Email=%s", domainUser.ID, domainUser.FirebaseUID, domainUser.Email)

	// Return the user object (ID is now populated by GORM)
	return domainUser, nil
}
