package sql

import (
	"context"
	"errors"
	"fmt"
	"log" // Use your logger

	"github.com/dgsaltarin/SharedBitesBackend/internal/domain"
	"github.com/dgsaltarin/SharedBitesBackend/internal/ports"

	"github.com/google/uuid"
	"gorm.io/gorm"
)

type gormUserRepository struct {
	db *gorm.DB
}

// NewGORMUserRepository creates a new GORM user repository.
func NewGORMUserRepository(db *gorm.DB) ports.UserRepository {
	if db == nil {
		log.Fatal("GORM DB cannot be nil for UserRepository")
	}
	return &gormUserRepository{db: db}
}

// Save creates or updates a user record based on the ID.
func (r *gormUserRepository) Save(ctx context.Context, user *domain.User) error {
	// GORM's Save updates all fields or inserts if primary key is zero/missing.
	// Since we use UUID generated by DB, we check if user exists first for clarity,
	// or rely on unique constraints, or use Upsert (more complex setup).
	// Let's stick to Save() which works well if ID is managed correctly.
	// If ID is set (meaning we fetched it before), it's an UPDATE.
	// If ID is uuid.Nil (meaning new object before insert), it's an INSERT.
	// GORM handles default UUID generation via `default:gen_random_uuid()` tag.

	if err := r.db.WithContext(ctx).Save(user).Error; err != nil {
		// Check for unique constraint violation (e.g., email or firebase_uid)
		// GORM doesn't provide strongly typed constraint errors easily across DBs.
		// Relying on service layer pre-checks is often more practical.
		// If constraints fail here, it likely indicates a race condition or logic error.
		log.Printf("Error saving user (ID: %s, Email: %s): %v", user.ID, user.Email, err)
		return fmt.Errorf("%w: %v", domain.ErrDatabaseUserCreationFailed, err) // Generic DB error
	}
	// ID field in user object should now be populated if it was an insert
	return nil
}

// FindByID retrieves a user by their internal database UUID.
func (r *gormUserRepository) FindByID(ctx context.Context, userID uuid.UUID) (*domain.User, error) {
	var user domain.User
	err := r.db.WithContext(ctx).Where("id = ?", userID).First(&user).Error
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, domain.ErrUserNotFound // Map to domain error
		}
		log.Printf("Error finding user by ID %s: %v", userID, err)
		return nil, fmt.Errorf("database error finding user by ID: %w", err)
	}
	return &user, nil
}

// FindByEmail retrieves a user by their email address.
func (r *gormUserRepository) FindByEmail(ctx context.Context, email string) (*domain.User, error) {
	var user domain.User
	// Use First to expect exactly one or zero results
	err := r.db.WithContext(ctx).Where("email = ?", email).First(&user).Error
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, domain.ErrUserNotFound // Map to domain error
		}
		log.Printf("Error finding user by email %s: %v", email, err)
		return nil, fmt.Errorf("database error finding user by email: %w", err)
	}
	return &user, nil
}

func (r *gormUserRepository) FindByFirebaseUID(ctx context.Context, firebaseUID string) (*domain.User, error) {
	var user domain.User
	err := r.db.WithContext(ctx).Where("firebase_uid = ?", firebaseUID).First(&user).Error
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, domain.ErrUserNotFound // Map to domain error
		}
		log.Printf("Error finding user by Firebase UID %s: %v", firebaseUID, err)
		return nil, fmt.Errorf("database error finding user by Firebase UID: %w", err)
	}
	return &user, nil
}
